---
nav:
  title: 简明教程
  order: 10
group:
	title: Front-End
	order: 10
title: Type Challenge
order: 34
---

# Type Challenge

## Easy

### Pick

Implement the built-in `Pick<T, K>` generic without using it.

Constructs a type by picking the set of properties `K` from `T`

For example

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false
}
```

**answer**

```ts
type MyPick<T, U extends keyof T> = {
  [K in U]: T[K]
}
```

**不知道的知识点**

**extends**

TypeScript 2.8 引入了条件关键字：`extends`

```ts
T extends U ? X : Y
```

> 如果`T`包含的类型是`U`包含类型的子集，那么取结果 `X`，否则取结果`Y`

**keyof**

TypeScript允许我们遍历某种类型属性，并通过`keyof`操作符提取其属性的名称。`keyof`操作符可以用于获取某种类型的所有键，其返回类型是联合类型

```ts
interface Person {
  name: string;
  age: number;
  location: string;
}

type K1 = keyof Person; // "name" | "age" | "location"
type K2 = keyof Person[];  // number | "length" | "push" | "concat" | ...
type K3 = keyof { [x: string]: Person };  // string | number
```

### Readonly

Implement the built-in `Readonly<T>` generic without using it.

Constructs a type with all properties of T set to readonly, meaning the properties of the constructed type cannot be reassigned.

For example

```ts
interface Todo {
  title: string
  description: string
}

const todo: MyReadonly<Todo> = {
  title: "Hey",
  description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```

**answer**

```ts
type MyReadonly<T> = {
  readonly [key in keyof T]: T[key]
}
```

### Tuple to Object

Give an array, transform into an object type and the key/value must in the given array

For example

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```

**answer**

```ts
type TupleToObject<T extends readonly Array<string | number | symbol>> = {
  [P in T[number]]: P;
}
```

### First of Array

Implement a generic `First<T>` that takes An Array `T` and return it's first element's type

For example

```ts
type arr1 = ['a', 'b', 'c'];
type arr2 = [3, 2, 1];

type head1 = First<arr1>	
```

**answer**

```ts
type First<T extends readonly unknown[]> = 
	T extends [infer ElementType, ...infer Tail]
		? Element
		: never
```

#### 知识点 - infer

`infer`可以在`extends`的条件语句中推断待推断的类型。

##### 作用

- infer 解包

  ```ts
  // 获取数组元素的类型，在不会 infer 之前是这样做的
  type Ids = number[];
  type Names = string[];
  
  type Unpacked<T> = T extends Names ? String : T extends Ids ? number : T;
  
  type idType = Unpacked<Ids>;	// idType 类型为 number
  type nameType = Unpacked<Names>;	// nameType 类型为 string
  ```

  ```ts
  type Unpacked<T> = T extends (infer R)[] ? R : T;
  
  type idType = Unpacked<Ids>;	// idType 类型为 number;
  type nameType = Unpacked<Names>;	// nameType 类型为 string;
  ```

- 推断联合类型

  ```ts
  type Foo<T> = T extends {a: infer U; b: infer U} ? U : never;
  
  type T10 = Foo<{ a: string; b: string }>;	// T10 类型为 string.
  type T11 = Foo<{ a: string; b: number }>;	// T11 类型为 string | number.
  ```

### Length Of Tuple

For given a tuple, you need to create a generic `Length`, pick the length of the tuple

For example

```ts
type tesla = ['tesla', 'model 3', 'model X', 'model Y']
type spaceX = ['FALCON 9', 'FALCON HEAVY', 'DRAGON', 'STARSHIP', 'HUMAN SPACEFLIGHT']

type teslaLength = Length<tesla>	// expected 4
type spaceXLength = Length<spaceX>	// expected 5
```

**answer**

```ts
// answer1
type Length<T extends readonly any[]> = T["length"]

// answer2
type Length<T> = T extends any[] ? T['length'] : never;

// answer3
type Length = T extends {length: infer Length} ? Length : never;
```

### Exclude

Implement the built-in `Exclude<T, U>`

> Exclude from T those types that are assignable to U

**answer**

```ts
type MyExclude<T, U> = T extends U ? never : T;
```

### Awaited

If we have a type which is wrapped type like Promise. How we can get a type which is inside the wrapped type? For example if we have `Promise<ExampleType>` how to get `ExampleType`？

> This question is ported from the [original article](https://dev.to/macsikora/advanced-typescript-exercises-question-1-45k4) by [@maciejsikora](https://github.com/maciejsikora)

**answer**

```ts
// answer1
type MyAwaited<T> = T extends Promise<infer R> ? MyAwaited<R> : T;

// answer2
type MyAwaited<T extends Promise<any>> = T extends Promise<infer R> ? (R extends Promise<any> ? MyAwaited<R> : R) : never;
```

### If

Implement utils `If` which accepts condition `C`, a truthy return type `T`, and a falsy return type `F`. `C` is expected to be either `true` or `false` while `T` and `F` can be any type.

For example:

```ts
type A = If<true, 'a', 'b'>  // expected to be 'a'
type B = If<false, 'a', 'b'> // expected to be 'b'
```

**answer**

```ts
type If<C extends boolean, T, F> = C extends true ? T : F;
```

### Concat

Implement the JavaScript `Array.concat` function in the type system. A type takes the two arguments. The output should be a new array that includes inputs in ltr order

For example

```ts
type Result = Concat<[1], [2]>	// expected to be [1, 2]
```

**answer**

```ts
type Concat<T extends unknown[], U extends unknown[]> = [...T, ...U]
```

### Includes

Implement the JavaScript `Array.includes` function in the type system. A type takes the two arguments. The output should be a boolean `true` or `false`.

For example

```ts
type isPillarMen = Includes<['Kars', 'Esidisi', 'Wamuu', 'Santana'], 'Dio'> // expected to be `false`
```

**answer**

```ts
type Includes<T extends readonly any[], U> = T extends [infer X, ...infer Y] ? Equal<X, U> extends true ? true :  Includes<Y, U> : false;
```

### Push

Implement the generic version of `Array.push`

For example

```ts
type Result = Push<[1, 2], '3'> // [1, 2, '3']
```

**answer**

```ts
type Push<T extends unknown[], U> = [...T, U];
```

### Unshift

Implement the type version of `Array.unshift`

For example

```ts
type Result = Unshift<[1, 2], 0> // [0, 1, 2,]
```

**answer**

```ts
type Unshift<T extends unknown[], U> = [U, ...T]
```

### Parameters

Implement the built-in Parameters generic without using it.

**answer**

```ts
type MyParameters<T extends (...args: any[]) => any> = T extends (...args: infer X) => any ? X : never;

type MyParameters<T> = T extends (...args: infer P ) => any ? P : T
```

## Medium

## Hard

## Extreme

