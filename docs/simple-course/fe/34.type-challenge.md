---
nav:
  title: 简明教程
  order: 10
group:
	title: Front-End
	order: 10
title: Type Challenge
order: 34
---

# Type Challenge

## Easy

### Pick

Implement the built-in `Pick<T, K>` generic without using it.

Constructs a type by picking the set of properties `K` from `T`

For example

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false
}
```

**answer**

```ts
type MyPick<T, U extends keyof T> = {
  [K in U]: T[K]
}
```

**不知道的知识点**

**extends**

TypeScript 2.8 引入了条件关键字：`extends`

```ts
T extends U ? X : Y
```

> 如果`T`包含的类型是`U`包含类型的子集，那么取结果 `X`，否则取结果`Y`

**keyof**

TypeScript允许我们遍历某种类型属性，并通过`keyof`操作符提取其属性的名称。`keyof`操作符可以用于获取某种类型的所有键，其返回类型是联合类型

```ts
interface Person {
  name: string;
  age: number;
  location: string;
}

type K1 = keyof Person; // "name" | "age" | "location"
type K2 = keyof Person[];  // number | "length" | "push" | "concat" | ...
type K3 = keyof { [x: string]: Person };  // string | number
```

### Readonly

Implement the built-in `Readonly<T>` generic without using it.

Constructs a type with all properties of T set to readonly, meaning the properties of the constructed type cannot be reassigned.

For example

```ts
interface Todo {
  title: string
  description: string
}

const todo: MyReadonly<Todo> = {
  title: "Hey",
  description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```

**answer**

```ts
type MyReadonly<T> = {
  readonly [key in keyof T]: T[key]
}
```



## Medium

## Hard

## Extreme

