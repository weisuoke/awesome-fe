---
nav:
  title: 简明教程
  order: 10
group:
	title: Front-End
	order: 10
title: Type Challenge
order: 34
---

# Type Challenge

## Easy

### Pick

Implement the built-in `Pick<T, K>` generic without using it.

Constructs a type by picking the set of properties `K` from `T`

For example

```ts
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>

const todo: TodoPreview = {
  title: 'Clean room',
  completed: false
}
```

**answer**

```ts
type MyPick<T, U extends keyof T> = {
  [K in U]: T[K]
}
```

**不知道的知识点**

**extends**

TypeScript 2.8 引入了条件关键字：`extends`

```ts
T extends U ? X : Y
```

> 如果`T`包含的类型是`U`包含类型的子集，那么取结果 `X`，否则取结果`Y`

**keyof**

TypeScript允许我们遍历某种类型属性，并通过`keyof`操作符提取其属性的名称。`keyof`操作符可以用于获取某种类型的所有键，其返回类型是联合类型

```ts
interface Person {
  name: string;
  age: number;
  location: string;
}

type K1 = keyof Person; // "name" | "age" | "location"
type K2 = keyof Person[];  // number | "length" | "push" | "concat" | ...
type K3 = keyof { [x: string]: Person };  // string | number
```

### Readonly

Implement the built-in `Readonly<T>` generic without using it.

Constructs a type with all properties of T set to readonly, meaning the properties of the constructed type cannot be reassigned.

For example

```ts
interface Todo {
  title: string
  description: string
}

const todo: MyReadonly<Todo> = {
  title: "Hey",
  description: "foobar"
}

todo.title = "Hello" // Error: cannot reassign a readonly property
todo.description = "barFoo" // Error: cannot reassign a readonly property
```

**answer**

```ts
type MyReadonly<T> = {
  readonly [key in keyof T]: T[key]
}
```

### Tuple to Object

Give an array, transform into an object type and the key/value must in the given array

For example

```ts
const tuple = ['tesla', 'model 3', 'model X', 'model Y'] as const

type result = TupleToObject<typeof tuple> // expected { tesla: 'tesla', 'model 3': 'model 3', 'model X': 'model X', 'model Y': 'model Y'}
```

**answer**

```ts
type TupleToObject<T extends readonly Array<string | number | symbol>> = {
  [P in T[number]]: P;
}
```

### First of Array

Implement a generic `First<T>` that takes An Array `T` and return it's first element's type

For example

```ts
type arr1 = ['a', 'b', 'c'];
type arr2 = [3, 2, 1];

type head1 = First<arr1>	
```

**answer**

```ts
type First<T extends readonly unknown[]> = 
	T extends [infer ElementType, ...infer Tail]
		? Element
		: never
```

#### 知识点 - infer

`infer`可以在`extends`的条件语句中推断待推断的类型。

##### 作用

- infer 解包

  ```ts
  // 获取数组元素的类型，在不会 infer 之前是这样做的
  type Ids = number[];
  type Names = string[];
  
  type Unpacked<T> = T extends Names ? String : T extends Ids ? number : T;
  
  type idType = Unpacked<Ids>;	// idType 类型为 number
  type nameType = Unpacked<Names>;	// nameType 类型为 string
  ```

  ```ts
  type Unpacked<T> = T extends (infer R)[] ? R : T;
  
  type idType = Unpacked<Ids>;	// idType 类型为 number;
  type nameType = Unpacked<Names>;	// nameType 类型为 string;
  ```

- 推断联合类型

  ```ts
  type Foo<T> = T extends {a: infer U; b: infer U} ? U : never;
  
  type T10 = Foo<{ a: string; b: string }>;	// T10 类型为 string.
  type T11 = Foo<{ a: string; b: number }>;	// T11 类型为 string | number.
  ```

## Medium

## Hard

## Extreme

